/*
 * ASKR Camera System - Secure Video Surveillance v3.0
 * 
 * API DOCUMENTATION:
 * 
 * 1. –ì–ï–ù–ï–†–ê–¶–ò–Ø STREAM –¢–û–ö–ï–ù–û–í:
 * 
 * –¢–æ–∫–µ–Ω –¥–ª—è –æ–¥–Ω–æ–π –∫–∞–º–µ—Ä—ã:
 * POST /api/stream-token
 * Headers: X-API-Key: your-api-key
 * Body: { "cameraId": 1, "userId": 123, "duration": "30m" }
 * 
 * –¢–æ–∫–µ–Ω –¥–ª—è —Å–ø–∏—Å–∫–∞ –∫–∞–º–µ—Ä:
 * POST /api/stream-token
 * Body: { "cameraIds": [1,2,3,4], "userId": 123, "duration": "1h" }
 * 
 * –¢–æ–∫–µ–Ω –¥–ª—è –≤—Å–µ—Ö –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –∫–∞–º–µ—Ä:
 * POST /api/stream-token
 * Body: { "scope": "all", "userId": 123, "duration": "2h" }
 * 
 * –ê–¥–º–∏–Ω—Å–∫–∏–π —Ç–æ–∫–µ–Ω (–¥–æ—Å—Ç—É–ø –∫–æ –≤—Å–µ–º –∫–∞–º–µ—Ä–∞–º):
 * POST /api/stream-token
 * Body: { "cameraIds": [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24] }
 * 
 * 2. –ò–°–ü–û–õ–¨–ó–û–í–ê–ù–ò–ï –¢–û–ö–ï–ù–û–í:
 * 
 * GET /stream/1/master.m3u8?token=xxx
 * GET /stream/1/720p/playlist.m3u8?token=xxx
 * GET /stream/1/720p/segment001.ts?token=xxx
 * 
 * 3. –ü–†–û–í–ï–†–ö–ê –¢–û–ö–ï–ù–ê:
 * 
 * GET /api/stream-token/verify?token=xxx
 * Headers: X-API-Key: your-api-key
 * 
 * 4. –ü–û–õ–£–ß–ï–ù–ò–ï –°–°–´–õ–û–ö –ù–ê –°–¢–†–ò–ú–´:
 * 
 * GET /api/camera/1/streams
 * Headers: X-API-Key: your-api-key
 * 
 * 5. –ë–ï–ó–û–ü–ê–°–ù–û–°–¢–¨:
 * 
 * - –í—Å–µ –ø—Ä—è–º—ã–µ –∑–∞–ø—Ä–æ—Å—ã –∫ .m3u8 –∏ .ts —Ñ–∞–π–ª–∞–º –ë–ï–ó /stream/ = 403 FORBIDDEN
 * - –¢–æ–∫–µ–Ω—ã –ø—Ä–æ–≤–µ—Ä—è—é—Ç—Å—è –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Å–µ–≥–º–µ–Ω—Ç–∞
 * - Rate limiting: API - 100 req/15min, Streams - 300 req/min
 * - –ê–¥–º–∏–Ω—ã –∏–º–µ—é—Ç –¥–æ—Å—Ç—É–ø –∫–æ –≤—Å–µ–º –∫–∞–º–µ—Ä–∞–º
 * - –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ —Ç–æ–ª—å–∫–æ –∫ –Ω–∞–∑–Ω–∞—á–µ–Ω–Ω—ã–º –∫–∞–º–µ—Ä–∞–º
 * 
 */

require('dotenv').config();
const express = require('express');
const fs = require('fs');
const path = require('path');
const jwt = require('jsonwebtoken');
const { spawn } = require('child_process');
const { PrismaClient } = require('@prisma/client');
const rateLimit = require('express-rate-limit');

const app = express();

// ===============================
// –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø –ò–ó ENV
// ===============================

const PORT = parseInt(process.env.BACKEND_PORT) || 8080;  // –ò–°–ü–†–ê–í–õ–ï–ù–û: parseInt
const JWT_SECRET = process.env.JWT_SECRET || 'askr-secret-key-2025';
const HLS_DIR = process.env.HLS_DIR || '/app/output';
const RECORDINGS_DIR = process.env.RECORDINGS_DIR || '/app/recordings';
const STREAM_TOKEN_EXPIRY = process.env.STREAM_TOKEN_EXPIRY || '30m';
const API_ACCESS_KEY = process.env.API_ACCESS_KEY || 'askr-api-key-2025';

console.log('üîß ASKR Camera System v3.0 Configuration:');
console.log(`üåê PORT: ${PORT} (type: ${typeof PORT})`);  // –î–û–ë–ê–í–õ–ï–ù–û: –æ—Ç–ª–∞–¥–∫–∞ —Ç–∏–ø–∞ –ø–æ—Ä—Ç–∞
console.log(`üìÅ HLS_DIR: ${HLS_DIR}`);
console.log(`üé¨ RECORDINGS_DIR: ${RECORDINGS_DIR}`);
console.log(`üîë API_ACCESS_KEY: ${API_ACCESS_KEY ? 'SET' : 'NOT SET'}`);
console.log(`üîê JWT_SECRET: ${JWT_SECRET ? 'SET' : 'NOT SET'}`);

// –°–æ–∑–¥–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –µ—Å–ª–∏ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É—é—Ç
[HLS_DIR, RECORDINGS_DIR].forEach(dir => {
    try {
        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
            console.log(`‚úÖ Created directory: ${dir}`);
        } else {
            console.log(`üìÅ Directory exists: ${dir}`);
        }
    } catch (error) {
        console.error(`‚ùå Failed to create directory ${dir}:`, error.message);
        // –ù–µ –ø–∞–¥–∞–µ–º, –∞ –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º —Ä–∞–±–æ—Ç—É
    }
});

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Prisma —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫
let prisma = null;
let prismaReady = false;

async function initPrisma() {
    try {
        prisma = new PrismaClient();
        await prisma.$connect();
        prismaReady = true;
        console.log('üì¶ Prisma Client connected successfully');
    } catch (error) {
        console.error('‚ùå Prisma initialization failed:', error.message);
        console.log('‚ö†Ô∏è  Running without database - some features disabled');
        prismaReady = false;
    }
}

// –ó–∞–ø—É—Å–∫–∞–µ–º –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é Prisma –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ
initPrisma();

// –•—Ä–∞–Ω–∏–º –∞–∫—Ç–∏–≤–Ω—ã–µ –∑–∞–ø–∏—Å–∏
const activeRecordings = new Map();

// ===============================
// RATE LIMITING
// ===============================

const apiLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 –º–∏–Ω—É—Ç
    max: 100, // –ª–∏–º–∏—Ç –¥–ª—è API
    message: { error: 'Too many API requests' }
});

const streamLimiter = rateLimit({
    windowMs: 1 * 60 * 1000, // 1 –º–∏–Ω—É—Ç–∞
    max: 300, // –ª–∏–º–∏—Ç –¥–ª—è —Å—Ç—Ä–∏–º–æ–≤
    message: { error: 'Too many stream requests' }
});

// ===============================
// MIDDLEWARE
// ===============================

app.use(express.json({ limit: '10mb' }));

// CORS
app.use((req, res, next) => {
    res.header('Access-Control-Allow-Origin', '*');
    res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
    res.header('Access-Control-Allow-Headers', 'Authorization, Content-Type, X-API-Key');
    
    if (req.method === 'OPTIONS') {
        return res.status(200).end();
    }
    next();
});

// –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ (–∏—Å–∫–ª—é—á–∞–µ–º .ts —Å–µ–≥–º–µ–Ω—Ç—ã —á—Ç–æ–±—ã –Ω–µ –∑–∞—Å–æ—Ä—è—Ç—å –ª–æ–≥)
app.use((req, res, next) => {
    if (!req.url.includes('.ts') && !req.url.includes('favicon')) {
        console.log(`${new Date().toISOString()} ${req.method} ${req.url} - ${req.ip}`);
    }
    next();
});

// ===============================
// MIDDLEWARE –§–£–ù–ö–¶–ò–ò
// ===============================

// –ü—Ä–æ–≤–µ—Ä–∫–∞ API –∫–ª—é—á–∞ (—Å fallback –±–µ–∑ –ë–î)
const verifyApiKey = async (req, res, next) => {
    const apiKey = req.headers['x-api-key'];
    
    if (!apiKey) {
        return res.status(401).json({ error: 'API key required' });
    }

    // –ï—Å–ª–∏ Prisma –Ω–µ –≥–æ—Ç–æ–≤–∞ - –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–æ—Å—Ç—É—é –ø—Ä–æ–≤–µ—Ä–∫—É
    if (!prismaReady) {
        if (apiKey === API_ACCESS_KEY || apiKey === 'askr-api-key-2025' || apiKey === 'askr-dev-key-2025') {
            req.apiKey = { key: apiKey, name: 'fallback' };
            return next();
        } else {
            return res.status(401).json({ error: 'Invalid API key (fallback mode)' });
        }
    }

    try {
        const validKey = await prisma.apiKey.findFirst({
            where: { 
                key: apiKey,
                isActive: true 
            }
        });

        if (!validKey) {
            return res.status(401).json({ error: 'Invalid API key' });
        }

        req.apiKey = validKey;
        next();
    } catch (error) {
        console.error('API key verification error:', error);
        // Fallback –∫ –ø—Ä–æ—Å—Ç–æ–π –ø—Ä–æ–≤–µ—Ä–∫–µ
        if (apiKey === API_ACCESS_KEY) {
            req.apiKey = { key: apiKey, name: 'fallback' };
            return next();
        }
        return res.status(500).json({ error: 'Internal server error' });
    }
};

// –ü—Ä–æ–≤–µ—Ä–∫–∞ JWT —Ç–æ–∫–µ–Ω–∞
const verifyToken = (req, res, next) => {
    const token = req.headers.authorization?.replace('Bearer ', '') || req.query.token;
    
    if (!token) {
        return res.status(401).json({ error: 'Token required' });
    }
    
    try {
        const decoded = jwt.verify(token, JWT_SECRET);
        req.user = decoded;
        next();
    } catch (error) {
        return res.status(401).json({ error: 'Invalid token', details: error.message });
    }
};

// –ü—Ä–æ–≤–µ—Ä–∫–∞ stream —Ç–æ–∫–µ–Ω–∞ –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ —Å–µ–≥–º–µ–Ω—Ç–∞–º
const verifyStreamToken = (req, res, next) => {
    const token = req.query.token || req.headers.authorization?.replace('Bearer ', '');
    
    if (!token) {
        return res.status(401).json({ error: 'Stream access denied: token required' });
    }
    
    try {
        const decoded = jwt.verify(token, JWT_SECRET);
        const cameraId = parseInt(req.params.cameraId);
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–∏–ø —Ç–æ–∫–µ–Ω–∞
        if (decoded.type !== 'stream') {
            return res.status(403).json({ error: 'Invalid token type for stream access' });
        }
        
        // –ê–¥–º–∏–Ω—Å–∫–∏–µ —Ç–æ–∫–µ–Ω—ã –∏–º–µ—é—Ç –¥–æ—Å—Ç—É–ø –∫–æ –≤—Å–µ–º –∫–∞–º–µ—Ä–∞–º
        if (decoded.userRole === 'ADMIN' || decoded.userRole === 'OPERATOR') {
            req.user = decoded;
            return next();
        }
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø –∫ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –∫–∞–º–µ—Ä–µ
        let hasAccess = false;
        
        // –ù–æ–≤—ã–π —Ñ–æ—Ä–º–∞—Ç —Å –º–∞—Å—Å–∏–≤–æ–º –∫–∞–º–µ—Ä
        if (decoded.cameras && Array.isArray(decoded.cameras)) {
            hasAccess = decoded.cameras.includes(cameraId);
        }
        // –°—Ç–∞—Ä—ã–π —Ñ–æ—Ä–º–∞—Ç —Å –æ–¥–Ω–æ–π –∫–∞–º–µ—Ä–æ–π (–æ–±—Ä–∞—Ç–Ω–∞—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å)
        else if (decoded.cameraId === cameraId) {
            hasAccess = true;
        }
        
        if (!hasAccess) {
            return res.status(403).json({ 
                error: 'Stream access denied: camera not in token scope',
                requestedCamera: cameraId,
                allowedCameras: decoded.cameras || [decoded.cameraId]
            });
        }
        
        req.user = decoded;
        return next();
        
    } catch (error) {
        if (error.name === 'TokenExpiredError') {
            return res.status(401).json({ error: 'Stream token expired' });
        }
        return res.status(401).json({ error: 'Stream access denied: invalid token' });
    }
};

// –ó–∞—â–∏—Ç–∞ –æ—Ç –ø—Ä—è–º–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞ –∫ HLS —Ñ–∞–π–ª–∞–º
const blockDirectHLSAccess = (req, res, next) => {
    // –ë–ª–æ–∫–∏—Ä—É–µ–º –≤—Å–µ –∑–∞–ø—Ä–æ—Å—ã –∫ .m3u8 –∏ .ts —Ñ–∞–π–ª–∞–º –∫–æ—Ç–æ—Ä—ã–µ –ù–ï –∏–¥—É—Ç —á–µ—Ä–µ–∑ –∑–∞—â–∏—â–µ–Ω–Ω—ã–µ —Ä–æ—É—Ç—ã
    if ((req.url.includes('.m3u8') || req.url.includes('.ts')) && !req.url.startsWith('/stream/')) {
        return res.status(403).json({ 
            error: 'Direct access to HLS files is forbidden',
            message: 'Use /stream/ endpoints with valid token'
        });
    }
    next();
};

// ===============================
// –ü–†–ò–ú–ï–ù–Ø–ï–ú MIDDLEWARE
// ===============================

app.use('/api/', apiLimiter);
app.use('/stream/', streamLimiter);
app.use(blockDirectHLSAccess);

// ===============================
// API ENDPOINTS
// ===============================

// –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –∫–∞–º–µ—Ä (—Å fallback –±–µ–∑ –ë–î)
app.get('/api/cameras/list', verifyApiKey, async (req, res) => {
    try {
        let cameras = [];
        
        if (prismaReady) {
            // –ò—Å–ø–æ–ª—å–∑—É–µ–º –ë–î –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–∞
            const dbCameras = await prisma.camera.findMany({
                where: { isActive: true },
                select: {
                    id: true,
                    channelId: true,
                    name: true,
                    position: true,
                    isActive: true
                },
                orderBy: { channelId: 'asc' }
            });
            cameras = dbCameras;
        } else {
            // Fallback - –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º 24 –∫–∞–º–µ—Ä—ã
            cameras = Array.from({length: 24}, (_, i) => ({
                id: i + 1,
                channelId: i + 1,
                name: `–ö–∞–º–µ—Ä–∞ ${i + 1}`,
                position: i + 1,
                isActive: true
            }));
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–∞—Ç—É—Å –∫–∞–º–µ—Ä –ø–æ –Ω–∞–ª–∏—á–∏—é HLS —Ñ–∞–π–ª–æ–≤
        const camerasWithStatus = cameras.map(camera => {
            const hlsFile = path.join(HLS_DIR, `camera_${camera.channelId}.m3u8`);
            const adaptiveDir = path.join(HLS_DIR, `camera_${camera.channelId}`);
            const masterPlaylist = path.join(adaptiveDir, 'master.m3u8');
            
            let status = 'offline';
            let adaptiveHls = false;
            
            if (fs.existsSync(masterPlaylist)) {
                status = 'online';
                adaptiveHls = true;
            } else if (fs.existsSync(hlsFile)) {
                status = 'online';
            }
            
            return {
                ...camera,
                status,
                adaptiveHls
            };
        });
        
        res.json({
            success: true,
            cameras: camerasWithStatus,
            total: camerasWithStatus.length,
            database_mode: prismaReady ? 'connected' : 'fallback'
        });
    } catch (error) {
        console.error('Error fetching cameras:', error);
        res.status(500).json({ error: 'Failed to fetch cameras' });
    }
});

// –ì–µ–Ω–µ—Ä–∞—Ü–∏—è stream —Ç–æ–∫–µ–Ω–∞ –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ –∫–∞–º–µ—Ä–∞–º
app.post('/api/stream-token', verifyApiKey, async (req, res) => {
    const { cameraId, cameraIds, userId, duration, scope } = req.body;

    try {
        let allowedCameras = [];
        let userInfo = null;

        // –ï—Å–ª–∏ —É–∫–∞–∑–∞–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∏ –ë–î –¥–æ—Å—Ç—É–ø–Ω–∞ - –ø–æ–ª—É—á–∞–µ–º –µ–≥–æ –ø—Ä–∞–≤–∞
        if (userId && prismaReady) {
            try {
                const user = await prisma.user.findFirst({
                    where: { 
                        id: userId,
                        isActive: true 
                    },
                    include: {
                        cameras: {
                            include: {
                                camera: {
                                    where: { isActive: true }
                                }
                            }
                        }
                    }
                });

                if (!user) {
                    return res.status(404).json({ error: 'User not found' });
                }

                userInfo = user;

                // –ê–¥–º–∏–Ω—ã –∏ –æ–ø–µ—Ä–∞—Ç–æ—Ä—ã –∏–º–µ—é—Ç –¥–æ—Å—Ç—É–ø –∫–æ –≤—Å–µ–º –∫–∞–º–µ—Ä–∞–º
                if (user.role === 'ADMIN' || user.role === 'OPERATOR') {
                    allowedCameras = Array.from({length: 24}, (_, i) => i + 1);
                } else {
                    // –û–±—ã—á–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ - —Ç–æ–ª—å–∫–æ –∫ –Ω–∞–∑–Ω–∞—á–µ–Ω–Ω—ã–º –∫–∞–º–µ—Ä–∞–º
                    allowedCameras = user.cameras.map(uc => uc.camera.channelId);
                }
            } catch (error) {
                console.error('Error fetching user:', error);
                // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –±–µ–∑ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            }
        }

        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∫–∞–∫–∏–µ –∫–∞–º–µ—Ä—ã –≤–∫–ª—é—á–∏—Ç—å –≤ —Ç–æ–∫–µ–Ω
        let targetCameras = [];

        if (scope === 'all') {
            if (userId && allowedCameras.length > 0) {
                // –¢–æ–∫–µ–Ω –¥–ª—è –≤—Å–µ—Ö –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –∫–∞–º–µ—Ä
                targetCameras = allowedCameras;
            } else {
                // –í—Å–µ 24 –∫–∞–º–µ—Ä—ã (–µ—Å–ª–∏ –Ω–µ—Ç –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è)
                targetCameras = Array.from({length: 24}, (_, i) => i + 1);
            }
        } else if (cameraIds && Array.isArray(cameraIds)) {
            // –¢–æ–∫–µ–Ω –¥–ª—è —Å–ø–∏—Å–∫–∞ –∫–∞–º–µ—Ä
            if (userId && allowedCameras.length > 0) {
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∏–º–µ–µ—Ç –¥–æ—Å—Ç—É–ø –∫–æ –≤—Å–µ–º –∑–∞–ø—Ä–∞—à–∏–≤–∞–µ–º—ã–º –∫–∞–º–µ—Ä–∞–º
                const unauthorizedCameras = cameraIds.filter(id => !allowedCameras.includes(id));
                if (unauthorizedCameras.length > 0) {
                    return res.status(403).json({ 
                        error: 'Access denied to some cameras',
                        unauthorized: unauthorizedCameras,
                        allowed: allowedCameras
                    });
                }
            }
            targetCameras = cameraIds.filter(id => id >= 1 && id <= 24);
        } else if (cameraId) {
            // –¢–æ–∫–µ–Ω –¥–ª—è –æ–¥–Ω–æ–π –∫–∞–º–µ—Ä—ã (–æ–±—Ä–∞—Ç–Ω–∞—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å)
            if (userId && allowedCameras.length > 0 && !allowedCameras.includes(cameraId)) {
                return res.status(403).json({ error: 'User does not have access to this camera' });
            }
            if (cameraId >= 1 && cameraId <= 24) {
                targetCameras = [cameraId];
            }
        } else {
            return res.status(400).json({ 
                error: 'Specify cameraId, cameraIds array, or scope="all"' 
            });
        }

        if (targetCameras.length === 0) {
            return res.status(400).json({ error: 'No valid cameras specified' });
        }

        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º stream —Ç–æ–∫–µ–Ω
        const tokenExpiry = duration || STREAM_TOKEN_EXPIRY;
        const streamToken = jwt.sign({
            type: 'stream',
            cameras: targetCameras, // –ú–∞—Å—Å–∏–≤ –∫–∞–º–µ—Ä
            cameraId: targetCameras[0], // –î–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
            userId: userId,
            userRole: userInfo?.role,
            scope: targetCameras.length === 1 ? 'single' : 'multiple',
            iat: Math.floor(Date.now() / 1000)
        }, JWT_SECRET, { expiresIn: tokenExpiry });

        res.json({
            success: true,
            token: streamToken,
            cameras: targetCameras,
            scope: targetCameras.length === 1 ? 'single' : 'multiple',
            expiresIn: tokenExpiry,
            user: userInfo ? {
                id: userInfo.id,
                username: userInfo.username,
                role: userInfo.role
            } : null,
            database_mode: prismaReady ? 'connected' : 'fallback'
        });

    } catch (error) {
        console.error('Error generating stream token:', error);
        res.status(500).json({ error: 'Failed to generate stream token' });
    }
});

// –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏ –ø–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ stream —Ç–æ–∫–µ–Ω–µ
app.get('/api/stream-token/verify', verifyApiKey, (req, res) => {
    const token = req.query.token || req.headers.authorization?.replace('Bearer ', '');
    
    if (!token) {
        return res.status(400).json({ error: 'Token parameter required' });
    }
    
    try {
        const decoded = jwt.verify(token, JWT_SECRET);
        
        if (decoded.type !== 'stream') {
            return res.status(400).json({ error: 'Not a stream token' });
        }
        
        res.json({
            valid: true,
            token: {
                type: decoded.type,
                cameras: decoded.cameras || [decoded.cameraId], // –ü–æ–¥–¥–µ—Ä–∂–∫–∞ —Å—Ç–∞—Ä–æ–≥–æ —Ñ–æ—Ä–º–∞—Ç–∞
                userId: decoded.userId,
                userRole: decoded.userRole,
                scope: decoded.scope || (decoded.cameraId ? 'single' : 'multiple'),
                issuedAt: new Date(decoded.iat * 1000),
                expiresAt: new Date(decoded.exp * 1000),
                timeToExpiry: Math.max(0, decoded.exp - Math.floor(Date.now() / 1000))
            }
        });
        
    } catch (error) {
        if (error.name === 'TokenExpiredError') {
            return res.json({
                valid: false,
                error: 'Token expired',
                expiredAt: new Date(error.expiredAt)
            });
        }
        
        return res.json({
            valid: false,
            error: 'Invalid token'
        });
    }
});

// –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Å—ã–ª–æ–∫ –Ω–∞ HLS –ø–æ—Ç–æ–∫–∏ –¥–ª—è –∫–∞–º–µ—Ä—ã
app.get('/api/camera/:cameraId/streams', verifyApiKey, async (req, res) => {
    const cameraId = parseInt(req.params.cameraId);

    if (cameraId < 1 || cameraId > 24) {
        return res.status(400).json({ error: 'Invalid camera ID (1-24)' });
    }

    try {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ —Ñ–∞–π–ª–æ–≤
        const hlsFile = path.join(HLS_DIR, `camera_${cameraId}.m3u8`);
        const adaptiveDir = path.join(HLS_DIR, `camera_${cameraId}`);
        const masterPlaylist = path.join(adaptiveDir, 'master.m3u8');

        const streams = {};

        if (fs.existsSync(masterPlaylist)) {
            streams.adaptive = `/stream/${cameraId}/master.m3u8`;
            streams.qualities = [
                { quality: '720p', url: `/stream/${cameraId}/720p/playlist.m3u8` },
                { quality: '480p', url: `/stream/${cameraId}/480p/playlist.m3u8` },
                { quality: '360p', url: `/stream/${cameraId}/360p/playlist.m3u8` }
            ];
        }

        if (fs.existsSync(hlsFile)) {
            streams.legacy = `/stream/${cameraId}/playlist.m3u8`;
        }

        if (Object.keys(streams).length === 0) {
            return res.status(404).json({ error: 'No streams available for this camera' });
        }

        res.json({
            success: true,
            cameraId: cameraId,
            streams: streams,
            note: "All URLs require a valid stream token in query parameter 'token' or Authorization header"
        });

    } catch (error) {
        console.error('Error fetching camera streams:', error);
        res.status(500).json({ error: 'Failed to fetch camera streams' });
    }
});

// ===============================
// –ó–ê–©–ò–©–ï–ù–ù–´–ï HLS ENDPOINTS
// ===============================

// Master –ø–ª–µ–π–ª–∏—Å—Ç (–∞–¥–∞–ø—Ç–∏–≤–Ω—ã–π)
app.get('/stream/:cameraId/master.m3u8', verifyStreamToken, (req, res) => {
    const cameraId = parseInt(req.params.cameraId);
    const filePath = path.join(HLS_DIR, `camera_${cameraId}`, 'master.m3u8');
    
    if (!fs.existsSync(filePath)) {
        return res.status(404).json({ error: 'Master playlist not found' });
    }
    
    res.setHeader('Content-Type', 'application/vnd.apple.mpegurl');
    res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');
    res.setHeader('Pragma', 'no-cache');
    res.setHeader('Expires', '0');
    res.sendFile(filePath);
});

// –ü–ª–µ–π–ª–∏—Å—Ç—ã –∫–∞—á–µ—Å—Ç–≤–∞
app.get('/stream/:cameraId/:quality/playlist.m3u8', verifyStreamToken, (req, res) => {
    const cameraId = parseInt(req.params.cameraId);
    const quality = req.params.quality;
    
    // –í–∞–ª–∏–¥–∞—Ü–∏—è –∫–∞—á–µ—Å—Ç–≤–∞
    const allowedQualities = ['720p', '480p', '360p'];
    if (!allowedQualities.includes(quality)) {
        return res.status(400).json({ error: 'Invalid quality parameter' });
    }
    
    const filePath = path.join(HLS_DIR, `camera_${cameraId}`, quality, 'playlist.m3u8');
    
    if (!fs.existsSync(filePath)) {
        return res.status(404).json({ error: 'Quality playlist not found' });
    }
    
    res.setHeader('Content-Type', 'application/vnd.apple.mpegurl');
    res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');
    res.setHeader('Pragma', 'no-cache');
    res.setHeader('Expires', '0');
    res.sendFile(filePath);
});

// Legacy –ø–ª–µ–π–ª–∏—Å—Ç
app.get('/stream/:cameraId/playlist.m3u8', verifyStreamToken, (req, res) => {
    const cameraId = parseInt(req.params.cameraId);
    const filePath = path.join(HLS_DIR, `camera_${cameraId}.m3u8`);
    
    if (!fs.existsSync(filePath)) {
        return res.status(404).json({ error: 'Legacy playlist not found' });
    }
    
    res.setHeader('Content-Type', 'application/vnd.apple.mpegurl');
    res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');
    res.setHeader('Pragma', 'no-cache');
    res.setHeader('Expires', '0');
    res.sendFile(filePath);
});

// TS —Å–µ–≥–º–µ–Ω—Ç—ã (–∞–¥–∞–ø—Ç–∏–≤–Ω—ã–µ)
app.get('/stream/:cameraId/:quality/:segment', verifyStreamToken, (req, res) => {
    const cameraId = parseInt(req.params.cameraId);
    const quality = req.params.quality;
    const segment = req.params.segment;
    
    // –í–∞–ª–∏–¥–∞—Ü–∏—è
    const allowedQualities = ['720p', '480p', '360p'];
    if (!allowedQualities.includes(quality)) {
        return res.status(400).json({ error: 'Invalid quality parameter' });
    }
    
    if (!segment.endsWith('.ts') || segment.includes('..') || segment.includes('/')) {
        return res.status(400).json({ error: 'Invalid segment format' });
    }
    
    const filePath = path.join(HLS_DIR, `camera_${cameraId}`, quality, segment);
    
    if (!fs.existsSync(filePath)) {
        return res.status(404).json({ error: 'Segment not found' });
    }
    
    res.setHeader('Content-Type', 'video/mp2t');
    res.setHeader('Cache-Control', 'public, max-age=3600');
    res.setHeader('Accept-Ranges', 'bytes');
    res.sendFile(filePath);
});

// TS —Å–µ–≥–º–µ–Ω—Ç—ã (legacy)
app.get('/stream/:cameraId/:segment', verifyStreamToken, (req, res) => {
    const cameraId = parseInt(req.params.cameraId);
    const segment = req.params.segment;
    
    if (!segment.endsWith('.ts') || segment.includes('..') || segment.includes('/')) {
        return res.status(400).json({ error: 'Invalid segment format' });
    }
    
    const filePath = path.join(HLS_DIR, segment);
    
    if (!fs.existsSync(filePath)) {
        return res.status(404).json({ error: 'Segment not found' });
    }
    
    res.setHeader('Content-Type', 'video/mp2t');
    res.setHeader('Cache-Control', 'public, max-age=3600');
    res.setHeader('Accept-Ranges', 'bytes');
    res.sendFile(filePath);
});

// ===============================
// –ó–ê–ü–ò–°–¨ –í–ò–î–ï–û
// ===============================

app.post('/api/camera/:cameraId/start-recording', verifyApiKey, async (req, res) => {
    const cameraId = parseInt(req.params.cameraId);
    
    if (cameraId < 1 || cameraId > 24) {
        return res.status(400).json({ error: 'Invalid camera ID (1-24)' });
    }
    
    try {
        if (activeRecordings.has(cameraId)) {
            return res.status(409).json({ error: 'Recording already in progress' });
        }

        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const filename = `camera_${cameraId}_${timestamp}.mp4`;
        const filePath = path.join(RECORDINGS_DIR, filename);
        
        const rtspUrl = `rtsp://${process.env.RTSP_USER}:${process.env.RTSP_PASS}@${process.env.RTSP_BASE_IP}:${process.env.RTSP_PORT}/chID=${cameraId}`;
        
        const ffmpegArgs = [
            '-rtsp_transport', 'tcp',
            '-i', rtspUrl,
            '-c:v', 'libx264',
            '-preset', 'medium',
            '-crf', '23',
            '-c:a', 'aac',
            '-b:a', '128k',
            '-f', 'mp4',
            filePath
        ];

        const ffmpegProcess = spawn('ffmpeg', ffmpegArgs);
        
        activeRecordings.set(cameraId, {
            process: ffmpegProcess,
            filename: filename,
            startTime: new Date(),
            filePath: filePath
        });

        ffmpegProcess.on('error', (error) => {
            console.error(`Recording error for camera ${cameraId}:`, error);
            activeRecordings.delete(cameraId);
        });

        ffmpegProcess.on('exit', (code) => {
            console.log(`Recording stopped for camera ${cameraId}, exit code: ${code}`);
            activeRecordings.delete(cameraId);
        });

        res.json({
            success: true,
            message: 'Recording started',
            cameraId: cameraId,
            filename: filename
        });

    } catch (error) {
        console.error('Error starting recording:', error);
        res.status(500).json({ error: 'Failed to start recording' });
    }
});

app.post('/api/camera/:cameraId/stop-recording', verifyApiKey, async (req, res) => {
    const cameraId = parseInt(req.params.cameraId);
    
    const recording = activeRecordings.get(cameraId);
    if (!recording) {
        return res.status(404).json({ error: 'No active recording for this camera' });
    }

    recording.process.stdin.write('q');
    
    res.json({
        success: true,
        message: 'Recording stopped',
        cameraId: cameraId,
        filename: recording.filename
    });
});

// ===============================
// –°–¢–ê–¢–£–° –ò –ú–û–ù–ò–¢–û–†–ò–ù–ì
// ===============================

app.get('/status', async (req, res) => {
    try {
        const m3u8Files = fs.readdirSync(HLS_DIR).filter(f => f.endsWith('.m3u8')).length;
        const tsFiles = fs.readdirSync(HLS_DIR).filter(f => f.endsWith('.ts')).length;
        const adaptiveDirs = fs.readdirSync(HLS_DIR).filter(f => 
            fs.statSync(path.join(HLS_DIR, f)).isDirectory() && f.startsWith('camera_')
        ).length;
        const recordingFiles = fs.existsSync(RECORDINGS_DIR) ? 
            fs.readdirSync(RECORDINGS_DIR).filter(f => f.endsWith('.mp4')).length : 0;
        
        res.json({ 
            status: 'ok', 
            service: 'askr-camera-system-v3',
            version: '3.0.0-fixed-port',
            timestamp: new Date().toISOString(),
            port: PORT,
            port_type: typeof PORT,
            hls_directory: HLS_DIR,
            recordings_directory: RECORDINGS_DIR,
            legacy_cameras: m3u8Files,
            adaptive_cameras: adaptiveDirs,
            total_segments: tsFiles,
            total_recordings: recordingFiles,
            active_recordings: activeRecordings.size,
            database_status: prismaReady ? 'connected' : 'fallback',
            features: {
                stream_tokens: true,
                protected_hls: true,
                api_integration: true,
                database_auth: prismaReady,
                rate_limiting: true,
                direct_access_blocked: true
            }
        });
    } catch (error) {
        res.status(500).json({
            status: 'error',
            service: 'askr-camera-system-v3', 
            error: error.message
        });
    }
});

// ===============================
// ERROR HANDLERS
// ===============================

// 404 –¥–ª—è –≤—Å–µ—Ö –æ—Å—Ç–∞–ª—å–Ω—ã—Ö –º–∞—Ä—à—Ä—É—Ç–æ–≤
app.use('*', (req, res) => {
    res.status(404).json({ 
        error: 'Not found',
        path: req.originalUrl,
        method: req.method,
        message: 'Use /api/ for API endpoints or /stream/ for protected video streams'
    });
});

// Graceful shutdown
process.on('SIGINT', async () => {
    console.log('\nüõë –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ä–∞–±–æ—Ç—ã —Å–∏—Å—Ç–µ–º—ã...');
    for (const [key, recording] of activeRecordings) {
        console.log(`Stopping recording: ${recording.filename}`);
        recording.process.stdin.write('q');
    }
    if (prisma) await prisma.$disconnect();
    setTimeout(() => process.exit(0), 5000);
});

process.on('SIGTERM', async () => {
    console.log('\nüõë –ü–æ–ª—É—á–µ–Ω SIGTERM, –∑–∞–≤–µ—Ä—à–∞–µ–º –≤—Å–µ –∑–∞–ø–∏—Å–∏...');
    for (const [key, recording] of activeRecordings) {
        console.log(`Stopping recording: ${recording.filename}`);
        recording.process.stdin.write('q');
    }
    if (prisma) await prisma.$disconnect();
    setTimeout(() => process.exit(0), 5000);
});

// –ó–∞–ø—É—Å–∫ —Å–µ—Ä–≤–µ—Ä–∞ - –ò–°–ü–†–ê–í–õ–ï–ù–û: —Å–ª—É—à–∞–µ–º –Ω–∞ –≤—Å–µ—Ö –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞—Ö —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º —Ç–∏–ø–æ–º –ø–æ—Ä—Ç–∞
app.listen(PORT, '0.0.0.0', () => {
    console.log(`üöÄ ASKR Camera System v3.0 running on port ${PORT}`);
    console.log(`üìÅ HLS files: ${HLS_DIR}`);
    console.log(`üé¨ Recordings: ${RECORDINGS_DIR}`);
    console.log(`üîê Protected HLS endpoints: /stream/*`);
    console.log(`üö´ Direct HLS access: BLOCKED`);
    console.log(`üìä Status: http://localhost:${PORT}/status`);
    console.log(`üîë Stream tokens required for all video access`);
    console.log(`‚ö° Rate limiting enabled`);
    console.log(`üóÑÔ∏è  Database: ${prismaReady ? 'Connected' : 'Fallback mode'}`);
});

module.exports = app;